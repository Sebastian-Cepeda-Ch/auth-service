version: '3.8'

services:
  
  # --- Tu Servicio de Autenticación (Requisito 2.1) ---
  auth-service:
    build:
      context: ./auth-service # Directorio donde está el Dockerfile
      dockerfile: Dockerfile
    ports:
      # Exponemos el 8000 al host (ej: 8000:8000) solo para debug.
      # En producción, solo NGINX necesitaría acceder a él.
      - "8001:8000" # Mapeo el 8001 del host al 8000 del contenedor para no chocar con el 80
      - "50051:50051" # API gRPC 
    env_file:
      - .env
    environment:
      # Pasamos variables de entorno a la aplicación
      - DATABASE_URL=${DATABASE_URL}
      - SECRET_KEY=${SECRET_KEY}
      - RABBITMQ_URL=${RABBITMQ_URL}
    volumes:
      # Montar el código para desarrollo (hot-reloading si usas --reload)
      - ./auth-service:/app
    depends_on:
      - mongo # Asegura que la DB inicie primero
      - rabbitmq 
      - loki # Esperamos a que el sistema de logs inicie
    # Ejecutamos el comando de compilación ANTES de iniciar el servidor.
    # Esto asegura que los archivos existan siempre.
    command: >
      sh -c "python -m grpc_tools.protoc -I./protos --python_out=. --grpc_python_out=. ./protos/auth.proto &&
             uvicorn main:app --host 0.0.0.0 --port 8000 --reload"
    networks:
      - microservices-net

  # --- Base de Datos MongoDB (Requisito 2.4) ---
  mongo:
    image: mongo:latest
    ports:
      # Exponer el puerto de Mongo al host (para conectar con MongoDB Compass, etc.)
      - "27017:27017"
    volumes:
      # Persistir los datos de la base de datos
      - mongo-data:/data/db
    networks:
      - microservices-net

  # --- RabbitMQ (Req. Entrega 3) ---
  rabbitmq:
    image: rabbitmq:3-management-alpine
    ports:
      - "5672:5672"      # Puerto para comunicación entre apps
      - "15672:15672"    # Puerto para la interfaz web de gestión
    networks:
      - microservices-net

  # --- Proxy Reverso NGINX (Requisito 2.5) ---
  nginx-proxy:
    image: nginx:latest
    ports:
      # El puerto principal de entrada a toda la aplicación
      - "80:80"
    volumes:
      # Montar nuestro archivo de configuración personalizado
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - auth-service # NGINX debe esperar a que el servicio de auth inicie
    networks:
      - microservices-net
  # --- MONITOREO (Stack PLG - Requisito 3.4) ---
  
  # 1. Loki (Base de datos de Logs)
  loki:
    image: grafana/loki:2.9.0
    ports:
      - "3100:3100"
    volumes:
      - ./monitoring/loki-config.yaml:/etc/loki/local-config.yaml
    command: -config.file=/etc/loki/local-config.yaml
    networks:
      - microservices-net

  # 2. Promtail (Recolector de Logs)
  promtail:
    image: grafana/promtail:2.9.0
    volumes:
      - ./monitoring/promtail-config.yaml:/etc/promtail/config.yaml
      # Montamos el socket de Docker para que Promtail pueda leer los logs de otros contenedores
      - /var/run/docker.sock:/var/run/docker.sock
    command: -config.file=/etc/promtail/config.yaml
    depends_on:
      - loki
    networks:
      - microservices-net

  # 3. Grafana (Dashboard Visual)
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin # Contraseña inicial
    depends_on:
      - loki
    networks:
      - microservices-net

# --- Gateway GraphQL (Req. 2.3) ---
  graphql-gateway:
    build:
      context: ./graphql-gateway
      dockerfile: Dockerfile
    ports:
      - "8002:8000" # Exponemos en 8002 para pruebas directas
    depends_on:
      - auth-service # Necesita que Auth esté vivo
    networks:
      - microservices-net


# --- Volúmenes para persistencia de datos ---
volumes:
  mongo-data:
    driver: local

# --- Red interna para que los contenedores se comuniquen ---
networks:
  microservices-net:
    driver: bridge